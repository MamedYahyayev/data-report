********************************************
               Version 2.0.0
********************************************

- Optimize pom.xml file ✅
- Store dependency versions in the <properties> ✅
- Add PMD plugin ✅
- Add javadoc plugin ✅
- Combine pmd, javadoc, test report results in the same place with folders ✅
- Add url, description tags ✅
- exclude some excel, config, txt files from the jar ✅
- Refactor test method names ✅
- Write Javadocs ✅
- Add exec and compiler plugins into pom.xml ✅
- Add profiles
    - no-tests ✅
- Convert project into multi module project ✅

********************************************
               Version 2.0.1
********************************************
- Change versions to 2.0.1-snapshot ✅
- Implement Download file feature ✅
- Fix redirect issue ✅
- Make downloaded file name available for download request ✅
- File not found when file generated automatically at runtime ✅
- Write test method for file download ✅
- Change rest endpoints' urls (both controller and javascript) ✅
- Configure File Saver Dialog window with extension ✅
- Write integration test ✅

********************************************
               Version 3.0.0
********************************************
- Build tree model ✅
- Insert OWASP dependency check plugin ✅
- Change Exception messages ✅
- Add <scope>test</scope> to mockito and junit ✅
- Change data-report-web project main class ✅
- Change owasp dependency check plugin phase to only install [ if it is available create issue on GitHub ] ✅
- Create a constructor inside WebPage class, and add second parameter that indicates driver window should be close or not ✅
- Check other interfaces for javadoc (especially base interfaces) ✅
- Configure mvn commands available for entire project (test, check, compile and so on.) ✅
- Convert implementation of DataAST tree to new Tree inside DataReportApplication ✅


********************************************
               Version 3.1.0
********************************************
- Create CLI ✅
- Create Custom Logging ✅
- Create a class for Console Messages for instance
    <code>
    String projectName = reader.readLine("Enter project name:", 3, "Project name cannot be null or empty");
    </code>
    In above case, we can create ConsoleRule class that will hold try count and exception message, if the rule fails
    there will be exception

- Convert all js files into ts files
- Change design of the website
- Create a builder for Tree


********************************************
             FUTURE Versions
********************************************
- After stable release, add @since annotation to every class or methods
- When writing methods like toUpperCase or toLowerCase use them with overloaded version of Locale
- Use string format for wrapping messages with dynamic values
- Create a class called Constants (or think a great name), that keeps project metadata such as version,
  project name, modules and so on.

- DataReportFileType for config json (for more info : JdlFileType) (getName, description, extension, singleton class)

- Do following code snippet
<code>

public static final String EXCEL = "..."

static {

    map = new HashMap(20); // use initial value
    map.put("xlsx", EXCEL);

}

</code>

[[[ Tree Implementation ]]]

- Tree Methods: getLast, getFirst, ChildNode, getNext, getPrev,  level
    preOrder, postOrder, post and preOrder from given location, nodes, hasParent
- Throw NoSucElementException inside of Tree
- Some available classes and interfaces: Abstract Tree, Tree, TreeBuilder, Node
- Node class methods or fields: level, order, location, value, parent, iterator (pre, post),
    height - longest path, depth, predecessor, successor, getParent, isRoot, HasSubNode (iterator),


<h1>Show error in Tree format</h1>
If there is a problem in your code show where it causes to problem

     location: A0 | A (root) | Level: A, order: 0
                        |
                        |
     location: B0 | B (node) | Level: B, order: 0
                        |
Node: C,           _____|_____ Node: C, Level: C, order: 1, location: C1
Level: C,
order: 0,
location: C0

- For this purpose create a file called LocationIndicator (Or Definer)

Child Calculation
root
 |
 |
 |  DataNode (Child #1)
 |        |
 |        |______ SubDataNode (Child #1.1) for main: (Child #2)
 |        |______ SubDataNode (Child #1.2) for main: (Child #3)
 |
 |
 |  DataNode (Child #4)
 |         |
 |         |______ SubDataNode (Child #2.1) for main: (Child #5)
 |         |______ SubDataNode (Child #2.2) for main: (Child #6)


 There will be 6 children for root, 2 children for child #1 and so on.

Tree Builder

Builder()
    .root(new DataNode()) // think for this one, maybe no need for root() method, the first counts as root
    .attributes()
    .node(
        new DataNode()
        .node()
        .attributes()
    )
    .attributes()
    .build();

node(
    "Parent",
    "selector",
    attributes()
    node("name", "selector", attributes(), subNode("name", "selector", attributes())),
    subNode("Title", "mb-1",  attributes()),
    subNode("Description", "mb-1",  attributes()),
    subNode("Starts", "mb-1",  attributes()),
)
.build()

subNodes doesn't have children

// Topic: Tree Format Plugin
Also create a plugin for this format of builder, because when you do format in IntelliJ IDEA or Eclipse,
it will format code by default.

Create a plugin for format builder classes, which will implement from class called TreeBuilder(find a good name)
which has build method, override it, and also some annotations for useful to

[[[ End of Tree Implementation ]]]

- If returned list or set is vulnerable, return unmodifiable list
- Some good names: isFinite, ensureNonNegative, firstCharToUpper, appendTo, skipNulls
- Look @throws documentations inside GraphBuilder (guava)

[[[ Cache Implementation ]]]

- Implement Cache<K, V>
    getIfPresent(key), put(key, value), CacheStats stats(), ConcurrentMap<K,V> asMap()
- CacheBuilder<K,V>
    maximumSize

[[[ End Cache Implementation ]]]


NOTE: Create Boundaries for the system: for the third party libraries, later to replace them easily without breaking the code


New Config File Design
Config file will includes different types of parts into config file, therefore there will be parts
                    ConfigFile
                        |
                        |
                        |
                  ConfigFilePart
    1) FilePart, FilePartValidator, FilePartField (enum)
    2) DataPart, DataPartValidator, DataPartField (enum)



- FileManager Design
 rename construct to create
 - create directories (if given path contains more than one non-existent directory, then it will create all of them)
 - create files - takes string[] file path or file[] (create files if all given path are valid)
 - create files (string[] , Predicate) - apply some filter or conditions


- Create a configuration class for other java applications
Idea: For example, when you want to give path to application instead of calling main method
create configuration class, specify path, then send that class object to initializer
Some arguments
    - config file path
    - report file output path

- Deploy jar file to nexus
- Change class, method, file, folder names
- Add package-info to every package and describe what the package includes and used for what ✅
- Move classes, interfaces of the parser package into relevant packages
- Restrict accessibility of the classes
- Complete todos
- Test following conditions
    - Check calling other dependencies main method from the demo application
    - Observe other codes
- Write Recursive methods for scraping and abstract syntax tree
- Write shell scripts to execute plugins or define maven profiles

Next Versions Ideas
- private int inheritanceLevel;
- provide flags for terminal operations

Add execution lifecycle phases to plugins


Add readme file
if possible change the group id and artifact id
do this in separate branch
Write some shell scripts for testing, pmd, javadoc and so on.

check other projects class packages

References
https://www.naukri.com/learning/articles/tree-data-structures-types-properties-and-applications/
https://www.simplilearn.com/tutorials/data-structure-tutorial/trees-in-data-structure
https://www.freecodecamp.org/news/all-you-need-to-know-about-tree-data-structures-bceacb85490c/




********************************************
      DataReport Architecture Class
********************************************
If this application used as a library for other applications, we need general class to collect information from user
and create a desired result for it. For instance, user may not know, it should send request to Scanner, then scraper, then exporter,
therefore we must consider to create a user friendly class. 

DataReport report = new DataReport() // can take DataReportConfiguration which can decide, config file type, report file type, extension, location and so on.
ReportFile reportFile = report.GenerateWith(ConfigFile configFile)

Those are enough for users to generate a desired result. 

For more info, look at classes: FastReport (in C#)
